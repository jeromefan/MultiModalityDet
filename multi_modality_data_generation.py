import os
import time
import carla
import pickle
import random
import shutil
import argparse
import numpy as np
import pandas as pd
from tqdm import tqdm
from queue import Queue
from queue import Empty


def get_args_parser():
    parser = argparse.ArgumentParser(description="CARLA Sensor")
    # 基本设置
    parser.add_argument(
        "-f",
        "--frames",
        default=200,
        type=int,
        help="Total frames.",
    )
    parser.add_argument(
        "--delta",
        default=0.05,
        type=int,
        help="fixed_delta_seconds, related with FPS, FPS*delta=1.",
    )
    parser.add_argument(
        "--num-npc",
        default=40,
        help="npc车辆的数量",
    )
    # RGB相机设置
    parser.add_argument("--cam", action="store_true", help="是否使用摄像头")
    parser.add_argument(
        "-r",
        "--resolution",
        metavar="WIDTHxHEIGHT",
        default="1600x900",
        help="window resolution.",
    )
    parser.add_argument(
        "--camera-fov",
        default=70.0,
        type=float,
        help="Horizontal field of view in degrees.",
    )
    # LiDAR设置
    parser.add_argument("--lidar", action="store_true", help="是否使用lidar")
    parser.add_argument(
        "--lidar-channels",
        default=32,
        type=int,
        help="Number of lasers.",
    )
    parser.add_argument(
        "--lidar-range",
        default=100.0,
        type=float,
        help="Maximum distance to measure/raycast in meters.",
    )
    parser.add_argument(
        "--lidar-points-per-second",
        default=1300000,
        type=int,
        help="Points generated by all lasers per second.",
    )
    parser.add_argument(
        "--lidar-upper-fov",
        default=10.0,
        type=float,
        help="Angle in degrees of the highest laser.",
    )
    parser.add_argument(
        "--lidar-lower-fov",
        default=-30.0,
        type=float,
        help="Angle in degrees of the lowest laser.",
    )

    return parser


def sensor_callback(data, queue):
    queue.put(data)


def run_simulation(args):
    client = carla.Client("localhost", 2000)
    client.set_timeout(5.0)
    world = client.get_world()
    blueprint_library = world.get_blueprint_library()

    traffic_manager = client.get_trafficmanager(8000)
    traffic_manager.set_synchronous_mode(True)

    original_settings = world.get_settings()
    settings = world.get_settings()
    settings.synchronous_mode = True
    settings.fixed_delta_seconds = args.delta
    world.apply_settings(settings)

    vehicle = None
    start_frame = None
    num_npc = args.num_npc
    vehicle_list = []
    walker_list = []

    if args.cam and args.lidar:
        cam_front = None
        cam_front_right = None
        cam_front_left = None
        cam_back = None
        cam_back_left = None
        cam_back_right = None
        lidar_top = None
    elif args.cam:
        cam_front = None
    elif args.lidar:
        lidar_top = None

    try:
        # 创建数据保存文件夹
        data_dir = time.strftime("%m%d-%H%M", time.localtime())
        if not os.path.exists("data"):
            os.mkdir("data")
        if os.path.exists(f"data/{data_dir}"):
            shutil.rmtree(f"data/{data_dir}")
        os.mkdir(f"data/{data_dir}")
        if args.cam:
            os.mkdir(f"data/{data_dir}/CAM_FRONT")
        if args.lidar:
            os.mkdir(f"data/{data_dir}/LIDAR_TOP")
        if args.cam and args.lidar:
            os.mkdir(f"data/{data_dir}/CAM_FRONT_RIGHT")
            os.mkdir(f"data/{data_dir}/CAM_FRONT_LEFT")
            os.mkdir(f"data/{data_dir}/CAM_BACK")
            os.mkdir(f"data/{data_dir}/CAM_BACK_RIGHT")
            os.mkdir(f"data/{data_dir}/CAM_BACK_LEFT")
            os.mkdir(f"data/{data_dir}/calib")

        # 创建 NPC
        vehicle_bps = blueprint_library.filter("vehicle.*")
        walker_bps = blueprint_library.filter("walker.pedestrian.*")
        vehicle_bps = [x for x in vehicle_bps if x.get_attribute("base_type") == "car"]
        vehicle_bps = sorted(vehicle_bps, key=lambda bp: bp.id)
        spawn_points = world.get_map().get_spawn_points()
        random.shuffle(spawn_points)
        walker_spawn_points = []
        for _ in range(100):
            walker_spawn_point = carla.Transform()
            while walker_spawn_point.location is None:
                walker_spawn_point.location = (
                    world.get_random_location_from_navigation()
                )
            walker_spawn_points.append(walker_spawn_point)

        for transform in spawn_points:
            if len(vehicle_list) >= num_npc:
                break
            vehicle_bp = random.choice(vehicle_bps)
            if vehicle_bp.has_attribute("color"):
                color = random.choice(
                    vehicle_bp.get_attribute("color").recommended_values
                )
                vehicle_bp.set_attribute("color", color)
            if vehicle_bp.has_attribute("driver_id"):
                driver_id = random.choice(
                    vehicle_bp.get_attribute("driver_id").recommended_values
                )
                vehicle_bp.set_attribute("driver_id", driver_id)
            vehicle = world.try_spawn_actor(vehicle_bp, transform)
            if vehicle is None:
                continue
            vehicle.set_autopilot(True)
            vehicle_list.append(vehicle)
        random.shuffle(spawn_points)
        for transform in spawn_points:
            if len(walker_list) >= num_npc / 2:
                break
            walker_bp = random.choice(walker_bps)
            if walker_bp.has_attribute("is_invincible"):
                walker_bp.set_attribute("is_invincible", "false")
            walker = world.try_spawn_actor(walker_bp, transform)
            if walker is None:
                continue
            walker.get_control().speed = 0.5
            walker.get_control().direction = transform.location + carla.Location(
                x=5, y=5
            )
            walker_list.append(walker)
        walker_controller_bp = blueprint_library.find("controller.ai.walker")
        for i in range(len(walker_list)):
            world.spawn_actor(walker_controller_bp, carla.Transform(), walker_list[i])

        # 创建自车并安装传感器
        vehicle_bp = blueprint_library.find("vehicle.audi.tt")
        if args.cam and args.lidar:
            cam_bp = blueprint_library.find("sensor.camera.rgb")
            cam_back_bp = blueprint_library.find("sensor.camera.rgb")
            lidar_bp = blueprint_library.find("sensor.lidar.ray_cast")
        elif args.cam:
            cam_bp = blueprint_library.find("sensor.camera.rgb")
        elif args.lidar:
            lidar_bp = blueprint_library.find("sensor.lidar.ray_cast")

        if args.cam:
            image_w = args.width
            image_h = args.height
            focal_distance = image_w / (2.0 * np.tan(70 * np.pi / 360.0))

        if args.cam and args.lidar:
            camera_intrinsic = np.identity(3)
            camera_intrinsic[0, 0] = camera_intrinsic[1, 1] = focal_distance
            camera_intrinsic[0, 2] = image_w / 2.0
            camera_intrinsic[1, 2] = image_h / 2.0
            focal_distance_back = image_w / (2.0 * np.tan(120 * np.pi / 360.0))
            camera_intrinsic_back = np.identity(3)
            camera_intrinsic_back[0, 0] = camera_intrinsic_back[
                1, 1
            ] = focal_distance_back
            camera_intrinsic_back[0, 2] = image_w / 2.0
            camera_intrinsic_back[1, 2] = image_h / 2.0

            cam_trans = np.array(
                [[0, 0, 1, 0], [1, 0, 0, 0], [0, -1, 0, 0], [0, 0, 0, 1]],
                dtype=np.float32,
            )
            lidar_trans = np.array(
                [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],
                dtype=np.float32,
            )
        if args.cam:
            cam_bp.set_attribute("image_size_x", f"{args.width}")
            cam_bp.set_attribute("image_size_y", f"{args.height}")
            cam_bp.set_attribute("fov", "70")
            cam_bp.set_attribute("focal_distance", f"{focal_distance}")
        if args.lidar:
            lidar_trans = np.array(
                [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],
                dtype=np.float32,
            )
            lidar_bp.set_attribute("dropoff_general_rate", "0.0")
            lidar_bp.set_attribute("dropoff_intensity_limit", "1.0")
            lidar_bp.set_attribute("dropoff_zero_intensity", "0.0")
            lidar_bp.set_attribute("channels", f"{args.lidar_channels}")
            lidar_bp.set_attribute("range", f"{args.lidar_range}")
            lidar_bp.set_attribute(
                "points_per_second", f"{args.lidar_points_per_second}"
            )
            lidar_bp.set_attribute("rotation_frequency", f"{1 / args.delta}")
            lidar_bp.set_attribute("upper_fov", f"{args.lidar_upper_fov}")
            lidar_bp.set_attribute("lower_fov", f"{args.lidar_lower_fov}")
        if args.cam and args.lidar:
            cam_back_bp.set_attribute("image_size_x", f"{args.width}")
            cam_back_bp.set_attribute("image_size_y", f"{args.height}")
            cam_back_bp.set_attribute("fov", "120")
            cam_back_bp.set_attribute("focal_distance", f"{focal_distance_back}")

        while vehicle is None:
            vehicle = world.try_spawn_actor(
                vehicle_bp, random.choice(world.get_map().get_spawn_points())
            )
        vehicle.set_autopilot(True)

        if args.lidar:
            lidar_top = world.spawn_actor(
                lidar_bp,
                carla.Transform(carla.Location(x=-0.2, y=0.0, z=1.9), carla.Rotation()),
                attach_to=vehicle,
            )
            lidar_top_queue = Queue()
            lidar_top.listen(lambda data: sensor_callback(data, lidar_top_queue))
        if args.cam:
            cam_front = world.spawn_actor(
                cam_bp,
                carla.Transform(
                    carla.Location(x=0.6, y=0.0, z=1.6), carla.Rotation(yaw=0)
                ),
                attach_to=vehicle,
            )
            cam_front_queue = Queue()
            cam_front.listen(lambda data: sensor_callback(data, cam_front_queue))
        if args.cam and args.lidar:
            cam_front_right = world.spawn_actor(
                cam_bp,
                carla.Transform(
                    carla.Location(x=0.4, y=-0.5, z=1.6), carla.Rotation(yaw=55)
                ),
                attach_to=vehicle,
            )
            cam_front_left = world.spawn_actor(
                cam_bp,
                carla.Transform(
                    carla.Location(x=0.4, y=0.5, z=1.6), carla.Rotation(yaw=-55)
                ),
                attach_to=vehicle,
            )
            cam_back = world.spawn_actor(
                cam_back_bp,
                carla.Transform(
                    carla.Location(x=-1.3, y=0.0, z=1.6), carla.Rotation(yaw=180)
                ),
                attach_to=vehicle,
            )
            cam_back_left = world.spawn_actor(
                cam_bp,
                carla.Transform(
                    carla.Location(x=-0.1, y=-0.5, z=1.6), carla.Rotation(yaw=-110)
                ),
                attach_to=vehicle,
            )
            cam_back_right = world.spawn_actor(
                cam_bp,
                carla.Transform(
                    carla.Location(x=-0.1, y=0.5, z=1.6), carla.Rotation(yaw=110)
                ),
                attach_to=vehicle,
            )
            cam_front_right_queue = Queue()
            cam_front_left_queue = Queue()
            cam_back_queue = Queue()
            cam_back_left_queue = Queue()
            cam_back_right_queue = Queue()
            cam_front_right.listen(
                lambda data: sensor_callback(data, cam_front_right_queue)
            )
            cam_front_left.listen(
                lambda data: sensor_callback(data, cam_front_left_queue)
            )
            cam_back.listen(lambda data: sensor_callback(data, cam_back_queue))
            cam_back_left.listen(
                lambda data: sensor_callback(data, cam_back_left_queue)
            )
            cam_back_right.listen(
                lambda data: sensor_callback(data, cam_back_right_queue)
            )

        pbar = tqdm(range(args.frames))
        for _ in pbar:
            world.tick()
            world_frame = world.get_snapshot().frame
            if start_frame is None:
                start_frame = world_frame
            pbar.set_description(f"Simulation: {world_frame - start_frame + 1}")

            spectator = world.get_spectator()
            spectator_location = vehicle.get_transform().location + carla.Location(z=50)
            spectator_rotation = carla.Rotation(pitch=-90)
            spectator.set_transform(
                carla.Transform(spectator_location, spectator_rotation)
            )
            try:
                if args.lidar:
                    lidar_top_data = lidar_top_queue.get(True, 1.0)
                if args.cam:
                    cam_front_data = cam_front_queue.get(True, 1.0)
                if args.cam and args.lidar:
                    cam_front_right_data = cam_front_right_queue.get(True, 1.0)
                    cam_front_left_data = cam_front_left_queue.get(True, 1.0)
                    cam_back_data = cam_back_queue.get(True, 1.0)
                    cam_back_left_data = cam_back_left_queue.get(True, 1.0)
                    cam_back_right_data = cam_back_right_queue.get(True, 1.0)
            except Empty:
                print("[Warning] Some sensor data has been missed")
                continue
            if args.cam and args.lidar:
                assert (
                    world_frame
                    == cam_front_data.frame
                    == cam_front_right_data.frame
                    == cam_front_left_data.frame
                    == cam_back_data.frame
                    == cam_back_left_data.frame
                    == cam_back_right_data.frame
                    == lidar_top_data.frame
                )
            elif args.cam:
                assert world_frame == cam_front_data.frame
            elif args.lidar:
                assert world_frame == lidar_top_data.frame

            filename = str(world_frame - start_frame + 1).rjust(4, "0")

            if args.cam and args.lidar:
                lidar_top_2_world = np.dot(
                    lidar_top.get_transform().get_matrix(), np.linalg.inv(lidar_trans)
                )

                cam_front_2_world = np.dot(
                    cam_front.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_front = np.dot(
                    np.linalg.inv(cam_front_2_world), lidar_top_2_world
                )

                cam_front_right_2_world = np.dot(
                    cam_front_right.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_front_right = np.dot(
                    np.linalg.inv(cam_front_right_2_world), lidar_top_2_world
                )

                cam_front_left_2_world = np.dot(
                    cam_front_left.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_front_left = np.dot(
                    np.linalg.inv(cam_front_left_2_world), lidar_top_2_world
                )

                cam_back_2_world = np.dot(
                    cam_back.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_back = np.dot(
                    np.linalg.inv(cam_back_2_world), lidar_top_2_world
                )

                cam_back_left_2_world = np.dot(
                    cam_back_left.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_back_left = np.dot(
                    np.linalg.inv(cam_back_left_2_world), lidar_top_2_world
                )

                cam_back_right_2_world = np.dot(
                    cam_back_right.get_transform().get_matrix(), cam_trans
                )
                lidar2cam_back_right = np.dot(
                    np.linalg.inv(cam_back_right_2_world), lidar_top_2_world
                )

                calib = dict(
                    CAM_FRONT=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_front.tolist(),
                    ),
                    CAM_FRONT_RIGHT=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_front_right.tolist(),
                    ),
                    CAM_FRONT_LEFT=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_front_left.tolist(),
                    ),
                    CAM_BACK=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_back.tolist(),
                    ),
                    CAM_BACK_LEFT=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_back_left.tolist(),
                    ),
                    CAM_BACK_RIGHT=dict(
                        img_path=f"{filename}.jpg",
                        cam2img=camera_intrinsic.tolist(),
                        lidar2cam=lidar2cam_back_right.tolist(),
                    ),
                )
                with open(f"data/{data_dir}/calib/{filename}.pkl", "wb") as f:
                    pickle.dump(calib, f)

            if args.cam:
                cam_front_data.save_to_disk(
                    f"data/{data_dir}/CAM_FRONT/{filename}_CAM_FRONT.jpg"
                )
            if args.cam and args.lidar:
                cam_front_right_data.save_to_disk(
                    f"data/{data_dir}/CAM_FRONT_RIGHT/{filename}_CAM_FRONT_RIGHT.jpg"
                )
                cam_front_left_data.save_to_disk(
                    f"data/{data_dir}/CAM_FRONT_LEFT/{filename}_CAM_FRONT_LEFT.jpg"
                )
                cam_back_data.save_to_disk(
                    f"data/{data_dir}/CAM_BACK/{filename}_CAM_BACK.jpg"
                )
                cam_back_left_data.save_to_disk(
                    f"data/{data_dir}/CAM_BACK_LEFT/{filename}_CAM_BACK_LEFT.jpg"
                )
                cam_back_right_data.save_to_disk(
                    f"data/{data_dir}/CAM_BACK_RIGHT/{filename}_CAM_BACK_RIGHT.jpg"
                )
            if args.lidar:
                points_v = np.frombuffer(
                    lidar_top_data.raw_data, dtype=np.dtype("f4")
                ).reshape(-1, 4)
                points_v = (lidar_trans @ points_v.T).T
                data_pd = pd.DataFrame(points_v)
                data_np = data_pd.values.astype(np.float32)
                data_np = np.concatenate(
                    (data_np, np.zeros((data_np.shape[0], 1), dtype=np.float32)), axis=1
                )
                data_np[:, 4] = np.arange(data_np.shape[0]) % 32
                data_np.astype(np.float32).tofile(
                    f"data/{data_dir}/LIDAR_TOP/{filename}_LIDAR_TOP.bin"
                )

    finally:
        print("simulation is finished!")
        world.apply_settings(original_settings)
        for veh in vehicle_list:
            veh.destroy()
        for walker in walker_list:
            walker.destroy()
        if args.cam:
            if cam_front:
                cam_front.destroy()
        if args.lidar:
            if lidar_top:
                lidar_top.destroy()
        if args.cam and args.lidar:
            if cam_front_right:
                cam_front_right.destroy()
            if cam_front_left:
                cam_front_left.destroy()
            if cam_back:
                cam_back.destroy()
            if cam_back_left:
                cam_back_left.destroy()
            if cam_back_right:
                cam_back_right.destroy()
        if vehicle:
            vehicle.destroy()


if __name__ == "__main__":
    args = get_args_parser()
    args = args.parse_args()
    if (not args.cam) and (not args.lidar):
        raise Exception("请至少指定一种模态！")
    if args.cam:
        args.width, args.height = [int(x) for x in args.resolution.split("x")]

    try:
        run_simulation(args)

    except KeyboardInterrupt:
        print("\nCancelled by user. Bye!")
